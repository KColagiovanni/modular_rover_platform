Designed and validated a modular autonomous robotic platform with fault-tolerant power management, SLAM-based navigation, and automated self-docking. Developed firmware, backend services, and integration test framework.

1. System Architecture
* High-Level Architecture
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚   Web Dashboard    â”‚
                â”‚  (React / Flask)   â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚ REST / WebSocket
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚  Robot Core (Pi)   â”‚
                â”‚  ROS 2 Nodes       â”‚
                â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚     â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”  â”Œâ”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€-â”
              â”‚ Vision  â”‚  â”‚ Nav Stack  â”‚
              â”‚ Camera  â”‚  â”‚ SLAM       â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚ MCU (Motor Ctrl) â”‚
              â”‚ State Machine    â”‚
              â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚ Motor Drivers   â”‚
            â”‚ Encoders        â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


* Software Stack
  * ROS 2 â€“ modular node-based system
  * Python for orchestration
  * C++ for performance-critical motor control
  * Flask or FastAPI backend
  * React frontend
  * SQLite or PostgreSQL for telemetry logging

* Modular Design Philosophy
  Design subsystems as swappable modules:
  Module           -->  Responsibility
  Power Module     -->  Battery, BMS, voltage regulation
  Motion Module    -->  Motors, encoders, drivers
  Compute Module   -->  SBC + MCU
  Sensor Module    -->  Lidar, ultrasonic, IMU
  Vision Module    -->  Camera + inference
  Docking Module   -->  Charging + alignment sensors

    Each should have:
    * Clear interface definition
    * Defined input/output spec
    * Test plan

2. Suggested Parts List
* Compute:
    * Raspberry Pi 5 (8GB) â€“ main compute - $157 PC + Power adapter + heatsinks/$134 PC only (Amazon or PiShop).
    * Arduino Nano / ESP32 â€“ real-time motor control - $15.99 Nano (Qty 3)/$15.19 ESP32-DevKitC (Qty 2)(Amazon).

* Power:
    * 12V Li-ion battery pack - $31.99 6000mAh w/Charger (Amazon)
    * 5V buck converter - $9.56 MP1584EN (Qty 5)(Amazon)
    * Fuse block - $6.19 5 x 20mm Fuse PCB Panel Mount Holder (Qty 10)(Amazon)
    * INA219 current sensor (for telemetry) - $8.19 (Qty 2)(Amazon)

* Motion:
    * 4WD metal gear motor chassis - $20 (Amazon).
    * Dual H-bridge motor driver (BTS7960 preferred over L298N) - $15.38 for 2 BTS7960(Amazon).
    * Wheel encoders and optical sensors - $6.96 for 40 wheel encoders & $9.99 for 10 optical sensors(Amazon).

* Sensors:
    * RPLidar A1 (SLAM capable) - $99.00 (Amazon).
    * IMU (MPU6050 or better) - $9.99 for 3 (Amazon).
    * Ultrasonic sensors - $9.99 for 5 (Amazon).
    * Pi Camera v3 - $30 for 75* or $36 for 120* wide angle (Amazon).

* Docking (Phase 2):
    * IR beacon - $17.99 for FSC-BP103B (Amazon)
    * Spring-loaded charging contacts - $9.49 for 2-Pin Magnetic Pogo Pin Connector (Amazon)
    * Charging controller module - $11.51 Brand: Yanmis (Amazon)

3. 3-Month Build Roadmap

Month 1: Base Platform + Manual Control

* Goals:
    * Assemble chassis
    * Motor control via MCU
    * Serial comm between Pi and MCU
    * Basic teleop via keyboard/web

* Deliverables:
    * Clean wiring harness
    * Defined comm protocol (JSON or binary)
    * Unit tests for motor commands

* Add:
    * Watchdog timer
    * Emergency stop logic

Month 2: Autonomy + Telemetry

* Goals:
    * Integrate Lidar
    * Implement SLAM using ROS2 Nav2 stack
    * Log telemetry to DB
    * Battery monitoring + low-voltage cutoff

* Deliverables:
    * Live map visualization
    * Battery % dashboard
    * Fault injection test (disconnect sensor mid-run)
    * This is where it starts looking like a real system.

Month 3: Self-Docking + Vision

* Goals:
    * Detect docking station
    * PID alignment control
    * Auto-return when battery < 20%
    * Add object detection

* Optional inference:
    * Run lightweight YOLO model locally

* Deliverables:
    * Fully autonomous patrol
    * Auto-dock + recharge
    * Recorded demo video

4. Senior-Level Material

* Add a Real Test Strategy *

* Create:
    * Requirements document
    * Interface Control Document (ICD)
    * State diagram
    * Fault tree analysis
    * Integration test matrix
    * Automated hardware-in-the-loop test script

* Optional:
    * Simulate motor feedback to test failure cases.

* Instrument Everything:
    * Log motor current spikes
    * Log encoder drift
    * Log SLAM confidence
    * Create test reports

ðŸ“ GitHub Structure
/firmware
/backend
/frontend
/hardware
/docs
/tests

* Include:
    * Architecture diagram
    * Test coverage report
    * Demo videos

* Stretch Goals:
    * OTA firmware updates
    * Encrypted communication
    * Redundant sensor fusion
    * Remote fleet management (if you build two)
