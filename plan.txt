Designed and validated a modular autonomous robotic platform with fault-tolerant power management, SLAM-based navigation, and automated self-docking. Developed firmware, backend services, and integration test framework.

1. System Architecture
* High-Level Architecture
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚   Web Dashboard    â”‚
                â”‚  (React / Flask)   â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚ REST / WebSocket
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚  Robot Core (Pi)   â”‚
                â”‚  ROS 2 Nodes       â”‚
                â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚     â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”  â”Œâ”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€-â”
              â”‚ Vision  â”‚  â”‚ Nav Stack  â”‚
              â”‚ Camera  â”‚  â”‚ SLAM       â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚ MCU (Motor Ctrl) â”‚
              â”‚ State Machine    â”‚
              â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚ Motor Drivers   â”‚
            â”‚ Encoders        â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


* Software Stack
  * ROS 2 â€“ modular node-based system
  * Python for orchestration
  * C++ for performance-critical motor control
  * Flask or FastAPI backend
  * React frontend
  * SQLite or PostgreSQL for telemetry logging

* Modular Design Philosophy
  Design subsystems as swappable modules:
  Module           -->  Responsibility
  Power Module     -->  Battery, BMS, voltage regulation
  Motion Module    -->  Motors, encoders, drivers
  Compute Module   -->  SBC + MCU
  Sensor Module    -->  Lidar, ultrasonic, IMU
  Vision Module    -->  Camera + inference
  Docking Module   -->  Charging + alignment sensors

    Each should have:
    * Clear interface definition
    * Defined input/output spec
    * Test plan

2. Suggested Parts List
* Compute:
    * Raspberry Pi 5 (8GB) â€“ main compute
    * Arduino Nano / ESP32 â€“ real-time motor control

* Power:
    * 12V Li-ion battery pack
    * 5V buck converter
    * Fuse block
    * INA219 current sensor (for telemetry)

* Motion:
    * 4WD metal gear motor chassis
    * Dual H-bridge motor driver (BTS7960 preferred over L298N)
    * Wheel encoders

* Sensors:
    * RPLidar A1 (SLAM capable)
    * IMU (MPU6050 or better)
    * Ultrasonic sensors
    * Pi Camera v3

* Docking (Phase 2):
    * IR beacon or AprilTag marker
    * Spring-loaded charging contacts
    * Charging controller module

3. 3-Month Build Roadmap

Month 1: Base Platform + Manual Control

* Goals:
    * Assemble chassis
    * Motor control via MCU
    * Serial comm between Pi and MCU
    * Basic teleop via keyboard/web

* Deliverables:
    * Clean wiring harness
    * Defined comm protocol (JSON or binary)
    * Unit tests for motor commands

* Add:
    * Watchdog timer
    * Emergency stop logic

Month 2: Autonomy + Telemetry

* Goals:
    * Integrate Lidar
    * Implement SLAM using ROS2 Nav2 stack
    * Log telemetry to DB
    * Battery monitoring + low-voltage cutoff

* Deliverables:
    * Live map visualization
    * Battery % dashboard
    * Fault injection test (disconnect sensor mid-run)
    * This is where it starts looking like a real system.

Month 3: Self-Docking + Vision

* Goals:
    * Detect docking station
    * PID alignment control
    * Auto-return when battery < 20%
    * Add object detection

* Optional inference:
    * Run lightweight YOLO model locally

* Deliverables:
    * Fully autonomous patrol
    * Auto-dock + recharge
    * Recorded demo video

4. Senior-Level Material

* Add a Real Test Strategy *

Create:
* Requirements document
* Interface Control Document (ICD)
* State diagram
* Fault tree analysis
* Integration test matrix
* Automated hardware-in-the-loop test script

Optional:
* Simulate motor feedback to test failure cases.

Instrument Everything:
* Log motor current spikes
* Log encoder drift
* Log SLAM confidence
* Create test reports

ðŸ“ GitHub Structure
/firmware
/backend
/frontend
/hardware
/docs
/tests

Include:
* Architecture diagram
* Test coverage report
* Demo videos

Stretch Goals:
* OTA firmware updates
* Encrypted communication
* Redundant sensor fusion
* Remote fleet management (if you build two)
